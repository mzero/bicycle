
Bicycle To Do
=============

Flexible Timing
---------------
[x] MIDI channel indicators under track icons

[] set tempo hi/lo from command line (?)
[] tempo knob is a bit fiddly with such a wide range...
	[] ? restrict to the hi/lo range?

[] snag clock estimator from Pulsar Buddy
[] feed MIDI events to estimator
[] expose position to estimator
[] accept tempo updates from estimator

[] when to use float, when to use double?
	- should this be keyed on processor?
[] what to do with clock when armed and TempoMode::inferred?
	- kill clock on first note played? or keep it running?
[] when TempoMode::inferred, and before anything is playing, the
	tempo display field should show "---"

On Deck
-------
[] awaiting off table needs to be by note & channel
  - that's too big to be reasonable - so will need to do some kind of hashed
    table scheme. In general, don't expect to be waiting more than 10 notes
    at a time.

[] measure processing time

[] odd immediate loop start with launchpad pro on program start
	- ALSA can deliver events from device from _before_ it was connected
	- probably need to flush the input when detecting a subscription

[] improve display thread - currently just multiple 10ms sleeps and updating
	- the display as fast as possible... will be excessive on a fast i2c machine
	- should somehow tie into the minDisplayReferesh time in bicycle.cpp's loop()

Bugs
----
[] handle failed beat estimates better
	- don't generate MIDI clock in these cases?

[] when 9 or more layers....
	- reduce each layer's trace to 1 or 2 pixels high, scrap end caps
	- fiddle with position of layers field and armed field to fit stuff
	- perhaps scrap message field in this case


[] consider using {fmt} for Log and Message functionality
	https://fmt.dev/latest/index.html

Features
--------
[] feedback to controller's buttons for mute and arm

[] MIDI channel shift (?)
[] track fx
  [] erosion: remove more and more notes (stable) as fader turned down
  [] quantization (?)
  [] 2x , 1/2x speed
  [] octave shift
  [] diatonic shift (?- ick, then you need to know the key...)
[] visual representation of recorded notes (? probably not really a good idea)
[] more than 10 layers?
  [] would need heap algo. for sorting next event
[] double tap clear to get quiet all now
	- finishes all notes immediately

Implementation
--------------
[x] displaying too often
	[x] what is the timing of the display operation?
		-- depends on the speed of the i2c bus: at 100k, it is about 170ms
			at 1M it is about 17ms


Other Ideas
-----------
[] Abelton Link (?)
[] layer range controls
[] layer fixes
	[] when armed, layers overwrite, but when you hit keep, it moves
		to next layer, and may leave remnants if you don't play a whole
		repeat
		- either a command to clear the layer  +1
		- or clear the layer on arm
		- or accept the punch-in/punch-out behavior as correct
		- or have keep stay on same layer?
	[] a way to over-dub into a layer, not punch?

[] long notes
	- note held all through the loop
	- note held near end of loop, through to start
		- esp. when same pitch as note at start of loop
	- when starting a new note on pitch X should cancel the pending
		note off for pitch X, yes?
		- also cancel or end any awaiting offs?

[] rationalize channels?
	- ch. 16 is control
	- but somethings on playing channels could be control
      like sustain pedal (CC 64) for "keep" function

[] async the loops if desired

[] handling control CCs that are momentary vs. toggle

[] visual, live configuration
  [] save & restore from files


HW Notes
========

USB Host
--------
Arudino Host Shield: (Retired)
	https://store.arduino.cc/usa/arduino-usb-host-shield
	open HW: https://www.arduino.cc/en/uploads/Main/USBHostShield-Rev2.pdf
	uses MAX3421E chip:
		USB host + 8 GPI + 8 GPO; via SPI
		https://www.maximintegrated.com/en/products/interface/controllers-expanders/MAX3421E.html

SparkFun's USB Shield is similar:
	https://www.sparkfun.com/products/9947
	same chip


Bitluni's USB host feather thing:
	https://www.youtube.com/watch?v=po3FBdY0GS4&feature=youtu.be
	CH559 dual USB host controller chip

Adafruit Trinket M0
	- has host ability
	- used in this MIDI USB Host thing
		https://hackaday.io/project/161715-midi-usb-host-to-midi-din-converter
		https://github.com/gdsports/midiuartusbh

Another approach - a Pi Zero and a hub
	- just use a script to aconnect every second


https://github.com/gdsports/USB_Host_Library_SAMD
